use super::consts::field::{FIELD_HEIGHT, FIELD_WIDTH};
use rand::Rng;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Direction {
    Up,
    Down,
    Left,
    Right,
}

impl Direction {
    pub fn random() -> Self {
        let mut rng = rand::rng();
        match rng.random_range(0..4) {
            0 => Direction::Up,
            1 => Direction::Down,
            2 => Direction::Left,
            _ => Direction::Right,
        }
    }

    pub fn copy_rotate(&self) -> Self {
        match self {
            Direction::Up => Direction::Right,
            Direction::Right => Direction::Down,
            Direction::Down => Direction::Left,
            Direction::Left => Direction::Up,
        }
    }

    pub fn rotate(&mut self) -> &Self {
        *self = self.copy_rotate();
        self
    }
}

// Tests generated by Junie AI
#[cfg(test)]
mod direction_tests {
    use super::*;

    #[test]
    fn test_copy_rotate() {
        assert_eq!(Direction::Up.copy_rotate(), Direction::Right);
        assert_eq!(Direction::Right.copy_rotate(), Direction::Down);
        assert_eq!(Direction::Down.copy_rotate(), Direction::Left);
        assert_eq!(Direction::Left.copy_rotate(), Direction::Up);
    }

    #[test]
    fn test_rotate() {
        let mut dir = Direction::Up;
        dir.rotate();
        assert_eq!(dir, Direction::Right);

        dir.rotate();
        assert_eq!(dir, Direction::Down);

        dir.rotate();
        assert_eq!(dir, Direction::Left);

        dir.rotate();
        assert_eq!(dir, Direction::Up);
    }
}

#[derive(Debug)]
pub enum PosError {
    OutOfBounds,
}

#[derive(Debug, Clone, Copy)]
pub struct Pos {
    pub x: u16,
    pub y: u16,
}

impl Pos {
    pub fn new(x: u16, y: u16) -> Result<Self, PosError> {
        if x >= FIELD_WIDTH || y >= FIELD_HEIGHT {
            return Err(PosError::OutOfBounds);
        }

        Ok(Pos { x, y })
    }

    pub fn zero() -> Self {
        Pos { x: 0, y: 0 }
    }

    pub fn copy_mod_x(&self, inc: i8) -> Self {
        let new_x = if inc < 0 && self.x < inc.unsigned_abs() as u16 {
            0 // Prevent underflow
        } else {
            (self.x as i16 + inc as i16).max(0) as u16
        };
        Pos {
            x: new_x,
            y: self.y,
        }
    }

    pub fn mod_x(&mut self, inc: i8) -> &Self {
        if inc < 0 && self.x < inc.unsigned_abs() as u16 {
            self.x = 0; // Prevent underflow
        } else {
            self.x = (self.x as i16 + inc as i16).max(0) as u16;
        }
        self
    }

    pub fn copy_mod_y(&self, inc: u16) -> Self {
        Pos {
            x: self.x,
            y: self.y + inc,
        }
    }

    pub fn mod_y(&mut self, inc: u16) -> &Self {
        self.y += inc;
        self
    }
}

// Tests generated by Junie AI
#[cfg(test)]
mod pos_tests {
    use super::*;

    #[test]
    fn test_new_valid_position() {
        let pos = Pos::new(0, 0).unwrap();
        assert_eq!(pos.x, 0);
        assert_eq!(pos.y, 0);

        let pos = Pos::new(FIELD_WIDTH - 1, FIELD_HEIGHT - 1).unwrap();
        assert_eq!(pos.x, FIELD_WIDTH - 1);
        assert_eq!(pos.y, FIELD_HEIGHT - 1);
    }

    #[test]
    fn test_new_invalid_position() {
        let pos = Pos::new(FIELD_WIDTH, 0);
        assert!(pos.is_err());

        let pos = Pos::new(0, FIELD_HEIGHT);
        assert!(pos.is_err());

        let pos = Pos::new(FIELD_WIDTH, FIELD_HEIGHT);
        assert!(pos.is_err());
    }

    #[test]
    fn test_zero() {
        let pos = Pos::zero();
        assert_eq!(pos.x, 0);
        assert_eq!(pos.y, 0);
    }

    #[test]
    fn test_copy_mod_x() {
        let pos = Pos::new(5, 5).unwrap();

        let new_pos = pos.copy_mod_x(3);
        assert_eq!(new_pos.x, 8);
        assert_eq!(new_pos.y, 5);

        let new_pos = pos.copy_mod_x(-3);
        assert_eq!(new_pos.x, 2);
        assert_eq!(new_pos.y, 5);

        // Test underflow prevention
        let pos = Pos::new(1, 5).unwrap();
        let new_pos = pos.copy_mod_x(-3);
        assert_eq!(new_pos.x, 0);
        assert_eq!(new_pos.y, 5);
    }

    #[test]
    fn test_mod_x() {
        let mut pos = Pos::new(5, 5).unwrap();

        pos.mod_x(3);
        assert_eq!(pos.x, 8);
        assert_eq!(pos.y, 5);

        pos.mod_x(-5);
        assert_eq!(pos.x, 3);
        assert_eq!(pos.y, 5);

        // Test underflow prevention
        pos.mod_x(-5);
        assert_eq!(pos.x, 0);
        assert_eq!(pos.y, 5);
    }

    #[test]
    fn test_copy_mod_y() {
        let pos = Pos::new(5, 5).unwrap();

        let new_pos = pos.copy_mod_y(3);
        assert_eq!(new_pos.x, 5);
        assert_eq!(new_pos.y, 8);
    }

    #[test]
    fn test_mod_y() {
        let mut pos = Pos::new(5, 5).unwrap();

        pos.mod_y(3);
        assert_eq!(pos.x, 5);
        assert_eq!(pos.y, 8);
    }
}
